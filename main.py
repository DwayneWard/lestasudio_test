#  Задание 1. Реализация из примера

def iseven_old(value):
    return value % 2 == 0


# В данной реализации необходимо сначала разделить число на 2, а затем сравнить остаток с 0 и выдать ответ

# Для определения четности можно использовать свойство того, что 0 это False, а 1 это True

def iseven(value: int) -> None:
    """
    Функция определения четности и нечетности числа, основанная на том, что 0 это False, а 1 это True
    :param value: Значение
    :return: None
    """
    if value % 2:
        print("Не четное")
    else:
        print("Четное")


# В данной реализации необходимо только разделить число на 0 и выдать результат по условию.

# Задание 2. Реализовано в файле py2.py

# Обе реализации предусматривают фиксированное значение цикла.
# В первом случае оно задается длиной первоначального списка, во втором параметром size.
# При использовании второго варианта элемент списка вставляется на место первого элемента в текущем списке.


# Обе реализации предусматривают фиксированное значение цикла.
# В первом случае оно задается длиной первоначального списка, во втором параметром size.
# При использовании второго варианта


# Задание 3.


def partition(nums: list, low: int, high: int) -> int:
    """
    Функция, которая определяет опорный элемент для сортировки

    :param nums: Список, который необходимо отсортировать
    :param low: Наименьший индекс
    :param high: Наибольший индекс
    :return: None
    """
    pivot = nums[(low + high) // 2]
    i = low - 1
    j = high + 1
    while True:
        i += 1
        while nums[i] < pivot:
            i += 1

        j -= 1
        while nums[j] > pivot:
            j -= 1

        if i >= j:
            return j

        # Если элемент с индексом i (слева от опорного) больше, чем
        # элемент с индексом j (справа от опорного), меняем их местами
        nums[i], nums[j] = nums[j], nums[i]


def quick_sort(nums: list) -> None:
    """
    Функция быстрой сортировки

    :param nums: Список, который нужно отсортировать
    :return: None
    """

    def _quick_sort(items: list, low: int, high: int) -> None:
        """
        Вспомогательная функция, которая будет вызываться рекурсивно

        :param items: Список, который необходимо отсортировать
        :param low: Наименьший индекс
        :param high: Наибольший индекс
        :return: None
        """
        if low < high:
            # This is the index after the pivot, where our lists are split
            split_index = partition(items, low, high)
            _quick_sort(items, low, split_index)
            _quick_sort(items, split_index + 1, high)

    _quick_sort(nums, 0, len(nums) - 1)


# Реализован алгоритм быстрой сортировки.
# Сложность алгоритма O(n*log n).
# В худшем случае (если опорный элемент будет равен наименьшему или наибольшему значению в списке)
# сложность составит O(n^2).
# Данная сложность позволяет сортировать списки большой длины затрачивая небольшое время и ресурсы.

random_list_of_nums = [17, 9, 14, 33, 10]
quick_sort(random_list_of_nums)
print(random_list_of_nums)
